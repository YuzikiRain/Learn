## 初始值

当对象在创建时获得了一个特定的值，我们就说这个对象被**初始化（initialized）**了。

初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，而赋值则是将对象的当前值擦除，并以一个新值来替代。

### 默认初始化（default initialized）

如果定义变量时没有指定初始值，则变量被默认初始化，此时变量被赋予了“默认值”。

默认值规则如下：

-   内置类型：由定义的位置决定
    -   函数体外部：初始化为0
    -   函数体内部：不会被初始化，值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误
-   自定义类型：由类确定

``` c++
std::string empty;		// empty非显式地初始化为一个空串
Sales_item item;		// 被默认初始化的Sales_item对象
```

### 列表初始化

``` c++
int units_sold = 0;
int units_sold(0);
int units_sold = {0};
int units_sold{0};
```

 当用于内置类型的变量时，如果初始值存在丢失信息（精度不足）的风险，则转换不会执行，编译器将报错：

``` c++
long double ld = 3.1415926536;
int a{ld}, b = {ld};			// 错误：转换不会执行，存在丢失信息的风险
int c(ld), d = ld;				// 正确：转换会被执行，因为我们显示地要求丢失部分值
```

对于使用long double的值来初始化int类型的a和b变量，编译器认为ld的小数部分会丢失掉，且int可能存不下ld的整数部分

### 声明和定义

#### 分离式编译（separate compilation）

为了允许将程序拆分成多个逻辑部分来编写，C++预研支持分离式编译机制，该机制允许将程序分割为若干个文件， 每个文件可以被独立编译。

如果将程序分为多个文件，则需要由在文件之间共享代码的方法。例如，一个文件的代码可能需要使用另一个文件中定义的变量。

为了支持分离式编译，C++语言将声明和定义区分开来。

**声明（declaration）**使得名字为程序所致，**一个文件如果想使用别处定义的名字，则必须包含对那个名字的声明**。

如果想声明而不是定义一个变量：

-   在变量名前添加关键字`extern`
-   不要显式地初始化变量

``` c++
extern int i;		// 声明i而不是定义i
int j;				// 声明并定义j
extern int k = 1;	// 定义k，而不是声明
```

**定义（definition）**负责创建与名字关联的实体。

变量声明规定了变量的类型和名字，定义也是如此。但是定义还会申请存储空间，也可能会为变量赋一个初始值。

可以有多个声明（使用变量前需要声明），但只能有一个定义。如果要在多个文件中使用同一个变量，就必须要将声明和定义分离。此时，变量的定义必须且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。

## 作用域

### 全局作用域（global scope）

定义于所有花括号之外，程序内全局可见，生命周期为整个程序运行期间

### 块作用域（block scope）

比如函数内定义的对象，分配在**栈**上，离开作用域时释放内存

### 嵌套的作用域

