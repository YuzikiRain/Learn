面向对象编程（object-oriented programming，OOP）的核心思想：

- 数据抽象：可以将类的接口与实现分离（声明和定义分离）
- 继承：可以定义相似的类型并对其相似关系建模
- 动态绑定：

派生类必须通过使用**类派生列表（class derivation list）**明确指出它是从哪些基类继承而来。类派生列表的形式是：基类名+冒号+可选的访问说明符+以逗号分隔的基类列表

``` c++
class baseClass
{
public:
	double Test(std::size_t) const;
}

class derivedClass : public baseClass
{
public:
    double Test(std::size_t) const override;
}
```

首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。

可将基类的指针和引用绑定到派生类对象上：当使用基类的指针或引用时，实际上我们并不清楚该指针或引用所绑定的对象的真实类型，对象可能是基类的对象，也可能是派生类的对象。

## 基类和派生类

### 类型转换与继承

当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的**静态类型(static type)**与该表达式表示对象的**动态类型(dynamic type)**区分开来。

- 表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；
- 动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。

如果表达式是指针或引用，则动态类型依赖于对象

如果表达式不是指针或引用，则它的动态类型永远与静态类型一致。

## 虚函数

用`virtual`关键字来表明这是一个虚函数。

在派生类中（不需要override关键字）同名方法会直接override对应基类的虚函数，而如果自身仍用virtual关键字，则表示可以继续被派生类override，否则不可以。

在C++语言中，只有当我们使用**基类的引用或指针**来调用一个**虚函数**时，才会发生动态绑定。

### 纯虚函数

``` c++
class baseClass
{
public:
	virtual	double Test(std::size_t) = 0;
}

class derivedClass : public baseClass
{
public:
    virtual double Test2(std::size_t);
}
```

在函数体的位置（即声明语句的分号之前）写`=0`就可以将一个虚函数声明为纯虚函数。

包含（或未override而直接继承）纯虚函数的类称为**抽象基类（abstract base class）**，抽象类不能被实例化。

`=0`只能出现在类内部的虚函数声明语句处。如果要为纯虚函数提供定义，只能将函数体定义在类的外部，即不能在类的内部为一个`=0`的函数提供函数体。

## 继承和访问控制

### 友元和继承

友元不能继承。

基类的友元在访问派生类成员时不具有特殊性，派生类的友元在访问基类成员时也是：

``` c++
class Base {
    //添加friend声明，其他成员与之前的版本一致
    friend class Pal;		//Pal在访问Base的派生类时不具有特殊性
};
class Pal {
public:
    int f(Base b) { return b.prot_ mem; } 		// 正确: Pal是Base的友元.
    int f2(Sneaky s) { return s.j; } 			// 错误: Pal不是Sneaky的友元
    //对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此
    int f3(Sneaky s) { return s.prot_ mem; } 	// 正确: Pal 是Base的友元
};
```

当class A将另class Base声明为友元时，这种友元关系只会对做出声明的类Base有效，因此对于class A来说，并不会对友元class Base的基类或派生类具有特殊的访问能力：

``` c++
// D2对Base的protected和private成员不具有特殊的访问能力
class D2 : public Pal {
public:
	int mem(Base b) { return b.prot_ mem; }		//错误:友元关系不能继承
};
```

### 默认的继承保护级别

struct和class唯一的差别只有默认成员访问说明符和默认派生访问说明符：class定义的类的成员是私有的，定义的派生类是私有继承；struct定义的类的成员是公有的，定义的派生类是公有继承：

``` c++
class Base { /* ... */ };
struct D1 : Base {/*...*/};		//默认public继承
class D2 : Base {/*...*/};		//默认private继承
```

### 继承中的类作用域

每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。

``` c++
Bulk_quote bulk;
cout << bulk.isbn() ;
```

- 因为我们是通过Bulk_ quote 的对象调用isbn的，所以首先在Bulk_ quote 中查找，这一步没有找到名字isbn。
- 因为Bulk_ quote 是Disc_ quote的派生类，所以接下来在Disc_ quote中查找，仍然找不到。
- 因为Disc_ quote是Quote的派生类，所以接着查找Quote;此时找到了名字isbn，所以我们使用的isbn最终被解析为Quote中的isbn。

#### 在编译时进行名字查找

一个对象、引用或指针的静态类型(参见15.2.3节，第532页)决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致(当使用基类的引用或指针时会发生这种情况，但是我们能使用哪些成员仍然是由静态类型决定的。

## 构造函数与拷贝控制

### 虚析构函数

如果基类的析构函数不是虚函数，当使用delete删除一个指向派生类对象的基类指针时将产生未定义的行为。

``` c++
class Quote {
public:
    //如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数
    virtual ~Quote() = default;	// 动态绑定析构函数
};

Quote *itemP = new Quote;		//静态类型与动态类型一致
delete itemP;					//调用Quote的析构函数
itemP = new Bulk_ quote; 		//静态类型与动态类型不一致
delete itemP;					//调用Bulk_ _quote的析构函数
```

### 合成拷贝控制与继承

与其他合成的构造函数、赋值运算符或析构函数类似，基类或派生类的合成拷贝控制成员的行为：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁。例如：

- 合成的Bulk_quote 默认构造函数运行Disc_quote 的默认构造函数，后者又运行Quote的默认构造函数。
- Quote的默认构造函数将bookNo成员默认初始化为空字符串，同时使用类内初始值将price初始化为0。
- Quote 的构造函数完成后，继续执行Disc_quote 的构造函数，它使用类内初始值初始化qty和discount。
- Disc_quote的构造函数完成后，继续执行Bulk_quote 的构造函数，但是它什么具体工作也不做。

对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。

### 派生类的拷贝控制成员

**派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分**。因此，派生类的拷贝和构造函数与拷贝控制移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。
和构造函数及赋值运算符不同的是，**析构函数只负责销毁派生类自己分配的资源**。如前所述，对象的成员是被隐式销毁的；类似的，派生类对象的基类部分也是自动销毁的。

#### 定义派生类的拷贝或移动构造函数
当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分:
``` c++
class Base { /* ...*/ };
class D: public Base {
public:
//默认情况下，基类的默认构造函数初始化对象的基类部分
//要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中
//显式地调用该构造函数
D(const D& d): Base (d)
//拷贝基类成员
/*D的成员的初始值*/{/*...*/}
D(D& d) : Base (std::move(d))
//移动基类成员
/*D的成员的初始值*/{/*...*/}*
```

初始值Base(d)将一个 D对象传递给基类构造函数。

尽管从道理上来说，**Base可以包含一个参数类型为D的构造函数，但是在实际编程过程中通常不会这么做。相反, Base(d) 一般会匹配Base的拷贝构造函数**。D类型的对象d将被绑定到该构造函数的Base&形参上。Base的拷贝构造函数负责将d的基类部分拷贝给要创建的对象。

假如我们没有提供基类的初始值的话：

``` c++
//D的这个拷贝构造函数很可能是不正确的定义
//基类部分被默认初始化， 而非拷贝
D(const D& d)		/*成员初始值，但是没有提供基类初始值*/
{ /* ...*/ }
```

在上面的例子中，Base的默认构造函数将被用来初始化D对象的基类部分。假定D的构造函数从d中拷贝了派生类成员，则这个新构建的对象的配置将非常奇怪:它的Base成员被赋予了默认值，而D成员的值则是从其他对象拷贝得来的。
**在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝(或移动)基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数。**

#### 派生类赋值运算符

#### 派生类析构函数

如前所述，在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的。因此，和构造函数及赋值运算符不同的是，派生类析构函数**只负责销毁由派生类自己分配的资源**：

``` c++
class D: public Base {
public:
    //Base::~Base被自动调用执行
    ~D() { /*该处由用户定义清除派生类成员的操作*/ } 
};
```

**对象销毁的顺序**正好与其创建的顺序相反：**派生类析构函数首先执行，然后是直接基类的析构函数**，以此类推，沿着继承体系的反方向直至最后。

**如果构造函数或析构函数调用了某个虚函数**，则我们**应该执行与构造函数或析构函数所属类型相对应的虚函数版本**（而不是其基类或派生类的版本）。

## 容器与继承

``` c++
class Animal 
{
public:
    Print() { cout << "I am an animal"; }
}
class Cat : public Animal
{
public:
    Print() { cout << "I am a Cat"; }    
}
```

### 在容器中放置对象

当使用容器存放继承体系中的对象时，必须采取间接存储的方式。因为不允许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器当中。

``` c++
vector<Animal> animals;
animal.push_back(Animal());
// 只能将对象的基类部分即Animal部分拷贝给animals
animal.push_back(Cat());

// 调用Animal定义的版本，打印"I am an animal"而不是cat
cout << animals.back().Print() << endl;
```

**当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”**，因此容器和存在继承关系的类型无法兼容。

### 在容器中放置（智能）指针

当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针（更好的选择是智能指针）。这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型：

``` c++
vector<shared_ptr<Animal>> animals;
animals.push_back(make_shared<Animal>());
animals.push_back(make_shared<Cat>());
//调用Animal定义的版本，打印"I am an animal"而不是cat
cout << animals.back()->Print() << endl;
```

因为basket存放着`shared_ptr`，所以我们必须解引用`animals.back()`的返回值以获得运行`Print`的对象。我们通过在`Print`的调用中使用`->`以达到这个目的。如我们所知，实际调用的`Print`版本依赖于指针所指对象的动态类型。值得注意的是，我们将animals定义成`shared_ptr<Animal>`，但是在第二个
`push_back`中传入的是一个`Cat` 对象的`shared_ptr`。

正如我们可以将一个派生类的普通指针转换成基类指针一样，我们也**能把一个派生类的智能指针转换成基类的智能指针**。

在此例中，`make_shared<Cat>`返回一个`shared_ptr<Cat>`对象， 但是当我们调用`push_back`时该对象被转换成`shared_ptr<Animal>`。 因此尽管在形式上有所差别，但实际上`animals`的所有元素的类型都是相同的。
