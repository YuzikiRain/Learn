面向对象编程（object-oriented programming，OOP）的核心思想：

- 数据抽象：可以将类的接口与实现分离（声明和定义分离）
- 继承：可以定义相似的类型并对其相似关系建模
- 动态绑定：

派生类必须通过使用**类派生列表（class derivation list）**明确指出它是从哪些基类继承而来。类派生列表的形式是：基类名+冒号+可选的访问说明符+以逗号分隔的基类列表

``` c++
class baseClass
{
public:
	double Test(std::size_t) const;
}

class derivedClass : public baseClass
{
public:
    double Test(std::size_t) const override;
}
```



首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。

可将基类的指针和引用绑定到派生类对象上：当使用基类的指针或引用时，实际上我们并不清楚该指针或引用所绑定的对象的真实类型，对象可能是基类的对象，也可能是派生类的对象。

## 基类和派生类

### 类型转换与继承

当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的**静态类型(static type)**与该表达式表示对象的**动态类型(dynamic type)**区分开来。

- 表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；
- 动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。

如果表达式是指针或引用，则动态类型依赖于对象

如果表达式不是指针或引用，则它的动态类型永远与静态类型一致。

## 虚函数

在C++语言中，只有当我们使用**基类的引用或指针**来调用一个**虚函数**时，才会发生动态绑定

### 纯虚函数

在函数体的位置（即声明语句的分号之前）写`=0`就可以将一个虚函数说明为纯虚函数

``` c++
class derivedClass : public baseClass
{
public:
    double Test2(std::size_t) = 0;
}
```

`=0`只能出现在类内部的虚函数声明语句处。如果要为纯虚函数提供定义，只能将函数体定义在类的外部，即不能在类的内部为一个`=0`的函数提供函数体。

含有（或未override而直接继承）纯虚函数的类称为**抽象基类（abstract base class）**，

## 继承和访问控制

### 友元和继承

友元不能继承。

基类的友元在访问派生类成员时不具有特殊性，派生类的友元在访问基类成员时也是：

``` c++
class Base {
    //添加friend声明，其他成员与之前的版本一致
    friend class Pal;		//Pal在访问Base的派生类时不具有特殊性
};
class Pal {
public:
    int f(Base b) { return b.prot_ mem; } 		// 正确: Pal是Base的友元.
    int f2(Sneaky s) { return s.j; } 			// 错误: Pal不是Sneaky的友元
    //对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此
    int f3(Sneaky s) { return s.prot_ mem; } 	// 正确: Pal 是Base的友元
};
```

当class A将另class Base声明为友元时，这种友元关系只会对做出声明的类Base有效，因此对于class A来说，并不会对友元class Base的基类或派生类具有特殊的访问能力：

``` c++
// D2对Base的protected和private成员不具有特殊的访问能力
class D2 : public Pal {
public:
	int mem(Base b) { return b.prot_ mem; }		//错误:友元关系不能继承
};
```

### 默认的继承保护级别

struct和class唯一的差别只有默认成员访问说明符和默认派生访问说明符：class定义的类的成员是私有的，定义的派生类是私有继承；struct定义的类的成员是公有的，定义的派生类是公有继承：

``` c++
class Base { /* ... */ };
struct D1 : Base {/*...*/};		//默认public继承
class D2 : Base {/*...*/};		//默认private继承
```

### 继承中的类作用域

每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。

``` c++
Bulk_quote bulk;
cout << bulk.isbn() ;
```

- 因为我们是通过Bulk_ quote 的对象调用isbn的，所以首先在Bulk_ quote 中查找，这一步没有找到名字isbn。
- 因为Bulk_ quote 是Disc_ quote的派生类，所以接下来在Disc_ quote中查找，仍然找不到。
- 因为Disc_ quote是Quote的派生类，所以接着查找Quote;此时找到了名字isbn，所以我们使用的isbn最终被解析为Quote中的isbn。

#### 在编译时进行名字查找

一个对象、引用或指针的静态类型(参见15.2.3节，第532页)决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致(当使用基类的引用或指针时会发生这种情况，但是我们能使用哪些成员仍然是由静态类型决定的。
