new和delete运算符不止可以每次分配/释放一个对象，也可以针对数组。

``` c++
// 分配5个int长度的对象，然后返回指向第1个对象的指针
int *piArray = new int[5];
// 也可以用一个表示数组类型的类型别名来分配数组
typedef int arrT[42];
int *p = new arrT;
// 编译器执行的形式如下
int *p = new int[42];
```

## 动态分配一个数组会得到一个数组元素类型的指针（而不是指向数组的指针）

虽然通常称`new T[]`分配的内存为“动态数组”，但是这种叫法一定程度上会造成误导。当使用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。（即使我们使用类型别名定义了一个数组类型，new也不会分配一个数组类型的对象）

由于分配的内存并不是一个数组类型，因此不能对动态数组调用begin或end，因为这些函数使用数组维度来返回指向首元素和尾后元素的指针。同理，也不能用范围for语句来处理“所谓的”动态数组中的元素。

## 初始化动态分配对象的数组

默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。

可以对数组中的元素进行值初始化（3.3.1节 定义和初始化vector对象），方法是在大小之后跟一堆空括号：

``` c++
int *pia = new int[10];				// 10个未初始化的int
int *pia2 = new int[10]();			// 10个值初始化为int的默认值0的int
string *psa = new string[10];		// 10个空string
string *psa2 = new string[10];		// 10个空string

// 新标准中，可以提供一个元素初始化器的花括号列表
int *pia3 = new int[3]{1,2,3};
string *psa3 = new string[10]{"a","b","c", string(3,"x")};		// 前4个用给定的初始化器初始化，剩余6个元素进行值初始化
```

## 动态分配一个空数组是合法的

``` c++
size_t n = get_size();
int *p = new int[n];
for (int *q = p; q != p + n; ++q)
    // 处理数组
```

get_size返回0时，代码仍能够正常工作。

我们不能创建一个大小为0的静态数组对象，但是可以定义一个长度为0的动态数组

``` c++
char arr[0];					// 错误：不能定义长度为0的（静态）数组		
char *cp = new char[0];			// 正确：但cp不能
```

