## 物理内存

### 直接访问物理内存

早期的计算机，运行程序就是将整个程序载入物理内存，但是直接访问物理内存有以下问题

-   地址空间不隔离：由于可以直接访问物理内存，没有任何隔离保护机制，不同程序之间可以互相访问彼此使用的地址，一些恶意程序可以轻易地改写其他程序的内存数据，还有一些非恶意但是有bug的程序也可能不小心修改了，这很容易造成其他程序的崩溃。**用户需要安全稳定的计算机环境**
-   内存使用效率低：如果内存不够新运行程序的程序使用，一种可用的方法是将其他（暂时不用的）程序的数据暂时写入到磁盘里，释放内存给新程序，等需要用到的时候再从磁盘里读入这些数据恢复之前的程序。但该过程有大量的数据IO（缓存：程序一般在一段时间内只会频繁地访问一小部分数据，这些数据一般又是紧密排列的），效率很低下
-   程序运行的地址不确定：程序每次从磁盘读入内存，都需要找到一块足够大小的空闲内存，这块空闲内存的地址是不固定的，有的程序访问数据和指令跳转时的目标地址是（相对）固定的，这给程序的编写造成了一定的麻烦

### 增加中间层：虚拟地址

将程序给出的地址看作是一种虚拟地址（Virtual Address），通过操作系统维护的映射表将这个虚拟地址转换成实际的物理地址，这就保证了不同程序之间能够访问的物理内存区域不会重叠，达到地址空间隔离

可以将虚拟地址想象成一个超大的数组，每个元素都占一个byte，数组大小对应地址空间大小，比如一台32位机器，拥有32条**地址线**（每条地址线想象成一个开关，一个bit），就可以最多表示2^32个byte（不是bit）即4GB的地址空间。

#### 分段（segmentation）

![image-20220404170942083](https://cdn.jsdelivr.net/gh/YuzikiRain/ImageBed@master/img/202204041709165.png)

假设有一块从0x00000000到0x00A00000的10MB大小的虚拟空间分配给程序A，可以将该空间范围映射到假设为从0x00100000到0x00B00000的物理地址空间，如何映射由操作系统来完成，实际的地址转换由硬件完成。

这解决了两个问题：

-   地址空间不隔离：如果程序A访问虚拟空间的地址超过了范围，硬件就会判断这是一个非法访问，拒绝这个地址请求，再将这个请求报告给操作系统或监控程序，由它来决定如何处理。
-   程序运行的地址不确定：对于每个程序来说，无论它们被分配到物理地址的哪一个区域，对于程序来说都是透明的，它们不需要关心物理地址的变化，它们只需要按照从地址0x00000000到0x00A00000来编写程序、放置变量，所以程序不再需要重定位。

分段没有解决内存使用效率问题，因为分段对内存区域的映射还是按照程序为单位，如果内存不足，被换入换出到磁盘的都是整个程序，粒度太大。

根据程序的局部性原理，当一个程序在运行时，在某个时间段内，它只是频繁地用到了一小部分数据，也就是说，程序的很多数据其实在一个时间段内都是不会被用到的。

#### 分页（Paging）

将地址空间人为地等分成固定大小的页，每一页的大小由硬件决定，或硬件支持多种大小的页，由操作系统选择决定页的大小。**以页为单位进行映射**

比如Intel Pentium系列处理器支持4KB或4MB的页大小，那么操作系统可以选择每页大小为4KB，也可以选择每页大小为4MB，但是在同一时刻只能选择一种大小，所以对整个系统来说，页就是固定大小的。目前几乎所有的PC上的操作系统都使用4KB大小的页。我们使用的PC机是32位的虚拟地址空间，也就是4GB，那么按4KB每页分的话，总共有1 048 576个页。物理空间也是同样的分法。

每个虚拟空间有8页，每页大小为1KB，那么虚拟地址空间就是8KB。我们假设该计算机有13条地址线，即拥有2^13的物理寻址能力，那么理论上物理空间可以多达8KB。但是出于种种原因，购买内存的资金不够，只买得起6KB的内存，所以物理空间其实真正有效的只是前6KB。

那么，当我们把进程的虚拟地址空间按页分割，把常用的数据和代码页装载到内存中，把不常用的代码和数据保存在磁盘里，当需要用到的时候再把它从磁盘里取出来即可。

以图1-6为例，我们假设有两个进程Process1和Process2，它们进程中的部分虚拟页面被映射到了物理页面，比如VP0、VP1和VP7映射到PP0、PP2和PP3；而有部分页面却在磁盘中，比如VP2和VP3位于磁盘的DP0和DP1中；另外还有一些页面如VP4、VP5和VP6可能尚未被用到或访问到，它们暂时处于未使用的状态。

在这里，我们把虚拟空间的页就叫**虚拟页**（VP，Virtual Page），把物理内存中的页叫做**物理页**（PP，Physical Page），把磁盘中的页叫做**磁盘页**（DP，Disk Page）。图中的线表示映射关系，我们可以看到虚拟空间的有些页被映射到同一个物理页，这样就可以实现内存共享。

图1-6中Process1的VP2和VP3不在内存中，但是当进程需要用到这两个页的时候，硬件会捕获到这个消息，就是所谓的页错误（Page Fault），然后操作系统接管进程，负责将VP2和VP3从磁盘中读出来并且装入内存，然后将内存中的这两个页与VP2和VP3之间建立映射关系。以页为单位来存取和交换这些数据非常方便，硬件本身就支持这种以页为单位的操作方式。

![image-20220404170920013](https://cdn.jsdelivr.net/gh/YuzikiRain/ImageBed@master/img/202204041709099.png)

图1-6

##### 保护

**保护**也是页映射的目的之一，简单地说就是每个页可以设置权限属性，谁可以修改，谁可以访问等，而只有操作系统有权限修改这些属性，那么操作系统就可以做到保护自己和保护进程。

##### 虚拟地址到物理地址的转换

虚拟存储的实现需要依靠硬件的支持，对于不同的CPU来说是不同的。但是几乎所有的硬件都采用一个叫**MMU（Memory Management Unit）**的部件来进行页映射

![image-20220404171137305](https://cdn.jsdelivr.net/gh/YuzikiRain/ImageBed@master/img/202204041711346.png)

在页映射模式下，CPU发出的是Virtual Address，即我们的程序看到的是虚拟地址。经过MMU转换以后就变成了Physical Address。一般MMU都集成在CPU内部了，不会以独立的部件存在。