### 原理
- 生成HashCode，即key
- 使用哈希函数将key映射到数组某个元素
- 哈希函数相当于给以一定规则将不同key划分到了不同区域。原本（无规律的）数据集合只能线性查找，但使用哈希函数则将查找限定在更小的一个明确的区域内
- 以一定空间换取一定时间

### 哈希函数

**特点**
- 确定性：相同的输入，得到相同的输出
- 哈希冲突：不同的输入值，可能得到相同的输出
- 不可逆性：从一个HashCode可能得到无数个不同明文，无法得知哪个明文对应这个HashCode
- 混淆特性：仅改变输入的部分值，一个具有强混淆特性的哈希函数会产生一个几乎完全不同的输出

### HashCode
生成方式
- int：直接使用
- 其他类型：取指向该对象的指针的指针的地址

### 哈希冲突
哈希函数将key映射到了数组相同的索引上

### 解决方案
##### 拉链法
在冲突的索引处创建列表，将发生冲突的key都装入到列表中（如果列表过长，可以采用高度平衡的二叉查找树来将时间复杂度从O(n)优化至O(logn))
##### 开放寻址法-线性探测
从冲突位置往后线性查找是否有空位，有就插入。超过哈希表尾部则环绕回到首部。
覆盖key基地址的集群称为key的主集群
缺点：经过的线性探测次数越多，主集群会越大，之后任何增删查操作都会变慢
##### 开放寻址法-二次方探测
从冲突位置偏移$1^2$，没有空位则改成偏移$2^2$**（注意不是在之前偏移的基础上再次偏移）**，以此类推，直到找到空位。超过哈希表尾部则环绕回到首部。
缺点：如果负载因子和散列表大小不满足条件，则可能永远无法找到空位。如果α<0.5且M是质数（> 3），那么我们总是可以使用二次探测找到一个空槽。 （α是加载因子，M是散列表大小）

我们将通过矛盾使用证据。 我们首先假设两个二次探测步骤：x和y，x！= y（假设x
h(v) + x*x = h(v) + y*y (mod M)
x*x = y*y (mod M)//从两边敲出h（v）
x*x - y*y = 0 (mod M) //将y * y移动到左边
(x-y)*(x+y) = 0 (mod M)//重新排列公式

现在，（x-y）或（x + y）必须等于零。 我们的假设是x != y,  那么（x-y）不能为0. 由于0≤ x
矛盾！
因此，第一个M / 2二次探测步骤不能产生相同的地址模M（如果我们将M设置为大于3的质数）

##### 开放寻址法-双重散列
如果冲突，则使用第二个

h(v)//基地址
(h(v)+ 1 * h2(v))％M //第一个探测步骤，如果有碰撞
(h(v)+ 2 * h2(v))％M //第2次探测步骤，如果仍有冲突
(h(v)+ 3 * h2(v))％M //第三次探测步骤，如果仍有冲突
...
(h(v)+ k * h2(v))％M //第k个探测步骤等...
就是这样，探测器根据第二个散列函数h2（v）的值跳转，根据需要环绕散列表。
通常（对于整数键），h2(v)= M' - v%M'其中M'是一个小于M的质数。这使得h2(v)∈[1..M']，它足够多样 二次聚类。
### 懒惰删除
删除时不直接移除，而是标记为Delete。添加时遇到则覆盖，获取时遇到则当作不存在。